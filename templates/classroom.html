<!DOCTYPE html>
<html>
<head>
    <title>Classroom: {{ roomName }}</title>
    <style>
        .video-container { display: flex; flex-direction: row; justify-content: center; }
        video { width: 45%; margin: 10px; border: 1px solid #ccc; }
        .controls { margin: 20px; text-align: center; }
        button { padding: 10px 20px; font-size: 16px; border-radius: 5px; border: none; background-color: #007bff; color: white; cursor: pointer; margin: 5px; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        #whiteboard { width: 100%; max-width: 800px; height: 400px; border: 1px solid #ccc; display: none; }
        .whiteboard-controls { display: none; margin: 10px; }
    </style>
</head>
<body>
    <h1>Classroom: {{ roomName }}</h1>
    <div class="video-container">
        <video id="localVideo" autoplay playsinline muted></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>
    <div class="controls">
        <button id="startVideo" {% if userRole == 'student' %}disabled{% endif %}>Start Video Session</button>
        <button id="toggleWhiteboard">Show Whiteboard</button>
        <button id="endSession">End Session</button>
    </div>
    <div class="whiteboard-container">
        <canvas id="whiteboard"></canvas>
        <div class="whiteboard-controls">
            <button id="toggleEraser">Toggle Eraser</button>
            <button id="clearBoard">Clear Whiteboard</button>
        </div>
    </div>
    <script src="/static/js/socket.io.min.js"></script>
    <script>
        const room = "{{ roomName | replace(' ', '-') | lower }}-{{ user_id }}";
        const userId = "{{ user_id }}";
        const userRole = "{{ userRole }}";
        let peerConnection;
        const socket = io();
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        // Video Session
        const startButton = document.getElementById('startVideo');
        if (userRole === 'tutor') {
            startButton.disabled = false;
            startButton.addEventListener('click', startVideoSession);
        }

        async function startVideoSession() {
            try {
                startButton.disabled = true;
                peerConnection = new RTCPeerConnection(configuration);
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                document.getElementById('localVideo').srcObject = stream;
                stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('signal', { candidate: event.candidate, room });
                    }
                };

                peerConnection.ontrack = (event) => {
                    document.getElementById('remoteVideo').srcObject = event.streams[0];
                };

                socket.emit('join', { room, user_id: userId });

                socket.on('role', async ({ role }) => {
                    console.log(`Assigned role: ${role}`);
                    if (role === 'offerer') {
                        const offer = await peerConnection.createOffer();
                        await peerConnection.setLocalDescription(offer);
                        socket.emit('signal', { sdp: peerConnection.localDescription, room });
                    }
                });

                socket.on('signal', async (data) => {
                    console.log(`Received signal: ${JSON.stringify(data)}`);
                    if (data.sdp) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                        if (data.sdp.type === 'offer') {
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            socket.emit('signal', { sdp: peerConnection.localDescription, room });
                        }
                    } else if (data.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                });
            } catch (error) {
                console.error('Error starting video:', error);
                alert('Failed to start video session. Please check permissions and try again.');
                startButton.disabled = false;
            }
        }

        document.getElementById('endSession').addEventListener('click', () => {
            if (peerConnection) {
                peerConnection.close();
                document.getElementById('localVideo').srcObject = null;
                document.getElementById('remoteVideo').srcObject = null;
            }
            socket.emit('session_update', { duration: 0 });
            window.location.href = '/dashboard';
        });

        // Whiteboard
        const whiteboard = document.getElementById('whiteboard');
        const ctx = whiteboard.getContext('2d');
        let drawing = false;
        let eraser = false;
        const drawW = 2, eraseW = 10;

        function resizeCanvas() {
            whiteboard.width = whiteboard.offsetWidth * window.devicePixelRatio;
            whiteboard.height = whiteboard.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function coords(e) {
            const r = whiteboard.getBoundingClientRect();
            const x = e.touches ? e.touches[0].clientX - r.left : e.offsetX;
            const y = e.touches ? e.touches[0].clientY - r.top : e.offsetY;
            return { x, y };
        }

        function startDraw(e) {
            e.preventDefault();
            const { x, y } = coords(e);
            drawing = true;
            ctx.beginPath();
            ctx.moveTo(x, y);
            socket.emit('whiteboard', { type: 'start', x, y, eraser, room });
        }

        function draw(e) {
            if (!drawing) return;
            e.preventDefault();
            const { x, y } = coords(e);
            ctx.lineWidth = eraser ? eraseW : drawW;
            ctx.strokeStyle = eraser ? '#fff' : '#000';
            ctx.lineCap = 'round';
            ctx.lineTo(x, y);
            ctx.stroke();
            socket.emit('whiteboard', { type: 'draw', x, y, eraser, room });
        }

        function endDraw(e) {
            if (!drawing) return;
            e.preventDefault();
            drawing = false;
            ctx.closePath();
            socket.emit('whiteboard', { type: 'end', room });
        }

        ['mousedown', 'mousemove', 'mouseup', 'mouseout'].forEach(ev => {
            whiteboard.addEventListener(ev, { mousedown: startDraw, mousemove: draw, mouseup: endDraw, mouseout: endDraw }[ev]);
        });

        ['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(ev => {
            whiteboard.addEventListener(ev, { touchstart: startDraw, touchmove: draw, touchend: endDraw, touchcancel: endDraw }[ev]);
        });

        document.getElementById('toggleWhiteboard').addEventListener('click', () => {
            const wb = document.getElementById('whiteboard');
            const wbControls = document.querySelector('.whiteboard-controls');
            const isVisible = wb.style.display === 'block';
            wb.style.display = isVisible ? 'none' : 'block';
            wbControls.style.display = isVisible ? 'none' : 'block';
            socket.emit('whiteboard', { type: 'toggle', visible: !isVisible, room });
        });

        document.getElementById('clearBoard').addEventListener('click', () => {
            ctx.clearRect(0, 0, whiteboard.width, whiteboard.height);
            socket.emit('whiteboard', { type: 'clear', room });
        });

        document.getElementById('toggleEraser').addEventListener('click', function() {
            eraser = !eraser;
            this.textContent = eraser ? 'Switch to Draw' : 'Toggle Eraser';
        });

        socket.on('whiteboard', data => {
            if (data.type === 'start') {
                ctx.beginPath();
                ctx.moveTo(data.x, data.y);
            } else if (data.type === 'draw') {
                ctx.lineWidth = data.eraser ? eraseW : drawW;
                ctx.strokeStyle = data.eraser ? '#fff' : '#000';
                ctx.lineCap = 'round';
                ctx.lineTo(data.x, data.y);
                ctx.stroke();
            } else if (data.type === 'end') {
                ctx.closePath();
            } else if (data.type === 'clear') {
                ctx.clearRect(0, 0, whiteboard.width, whiteboard.height);
            } else if (data.type === 'toggle') {
                document.getElementById('whiteboard').style.display = data.visible ? 'block' : 'none';
                document.querySelector('.whiteboard-controls').style.display = data.visible ? 'block' : 'none';
            }
        });
    </script>
</body>
</html>