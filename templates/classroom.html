<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
<script>
  const socket = io();
  const room = "{{ room_slug }}";
  const userId = "{{ user_id }}";
  let role, pc, localStream;
  let iceBuffer = [];

  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  function log(msg) {
    const d = document.getElementById('log');
    const t = new Date().toLocaleTimeString();
    d.innerHTML += `[${t}] ${msg}<br>`;
    d.scrollTop = d.scrollHeight;
    console.log(`[${t}] ${msg}`);
  }

  // Join room
  socket.on('connect', () => {
    socket.emit('join', { room, user_id: userId });
    log('Socket connected');
  });
  socket.on('disconnect', () => {
    document.getElementById('reconnectMessage').style.display = 'block';
    log('Socket disconnected');
  });
  socket.on('connect', () => {
    document.getElementById('reconnectMessage').style.display = 'none';
  });

  // Receive your role then init RTCPeerConnection
  socket.on('role', ({ role: r }) => {
    role = r;
    log(`Assigned role: ${role}`);
    initPeerConnection();
  });

  function initPeerConnection() {
    pc = new RTCPeerConnection(config);

    // Answerer declares recvonly m-lines up front
    if (role === 'answerer') {
      pc.addTransceiver('video', { direction: 'recvonly' });
      pc.addTransceiver('audio', { direction: 'recvonly' });
      log('Answerer: added recvonly transceivers');
    }

    // Offerer kicks off negotiation whenever tracks/transceivers change
    if (role === 'offerer') {
      pc.onnegotiationneeded = async () => {
        try {
          log('Negotiation needed—creating offer');
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit('signal', { sdp: pc.localDescription, room });
          log('Offer created & sent');
        } catch (e) {
          log('Negotiation error: ' + e.message);
        }
      };
    }

    pc.onicecandidate = e => {
      if (e.candidate) {
        socket.emit('signal', { candidate: e.candidate, room });
        log('Sent ICE candidate');
      }
    };

    pc.ontrack = e => {
      document.getElementById('remoteVideo').srcObject = e.streams[0];
      log('Received remote track');
    };

    pc.onconnectionstatechange = () => {
      log('Connection state: ' + pc.connectionState);
    };
    pc.oniceconnectionstatechange = () => {
      log('ICE state: ' + pc.iceConnectionState);
    };
  }

  // Manual Start Video button (both roles)
  document.getElementById('startVideo').onclick = async () => {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      document.getElementById('localVideo').srcObject = localStream;
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      log('Local media ready & tracks added');
      // NOTE: on the offerer side, adding tracks will fire onnegotiationneeded automatically
    } catch (e) {
      log('getUserMedia failed: ' + e.message);
      alert('Unable to access camera & mic.');
    }
  };

  // Handle SDP & ICE from remote peer
  socket.on('signal', async data => {
    try {
      if (data.sdp) {
        const desc = new RTCSessionDescription(data.sdp);

        if (desc.type === 'offer' && role === 'answerer') {
          log('Offer received');
          await pc.setRemoteDescription(desc);

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { sdp: pc.localDescription, room });
          log('Answer created & sent');

          await drainIce();
        }
        else if (desc.type === 'answer' && role === 'offerer') {
          log('Answer received');
          await pc.setRemoteDescription(desc);
          await drainIce();
        }
      }
      else if (data.candidate) {
        const cand = new RTCIceCandidate(data.candidate);
        if (pc.remoteDescription && pc.remoteDescription.type) {
          await pc.addIceCandidate(cand);
          log('ICE candidate added');
        } else {
          iceBuffer.push(cand);
          log('ICE candidate buffered');
        }
      }
    } catch (err) {
      log('Signal handling error: ' + err.message);
    }
  });

  async function drainIce() {
    for (const c of iceBuffer) {
      try {
        await pc.addIceCandidate(c);
        log('Drained ICE');
      } catch (e) {
        console.warn('Failed to add buffered ICE:', e);
      }
    }
    iceBuffer = [];
  }

  // …and your whiteboard / endSession code goes here unchanged…
</script>
